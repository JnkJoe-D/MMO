# æŠ€èƒ½ç¼–è¾‘å™¨æ’­æ”¾å™¨ç³»ç»Ÿ â€” æ¶æ„æ–¹æ¡ˆï¼ˆæœ€ç»ˆç‰ˆï¼‰

## æ¦‚è¿°

æ•°æ®ï¼ˆClip/Trackï¼‰ä¸æ‰§è¡Œé€»è¾‘ï¼ˆProcessï¼‰åˆ†ç¦»ï¼Œé€šè¿‡ Runner é©±åŠ¨ Process ç”Ÿå‘½å‘¨æœŸã€‚æ”¯æŒç¼–è¾‘å™¨é¢„è§ˆä¸è¿è¡Œæ—¶æ‰§è¡Œã€‚

---

## 1. æ•´ä½“æ¶æ„

```mermaid
graph TB
    subgraph "å¤–éƒ¨é©±åŠ¨æº"
        MONO["SkillLifecycleManager<br/>(MonoBehaviour å•ä¾‹)"]
        ED["EditorApplication.update<br/>TimeStepMode å†³å®š dt"]
        FS["å¸§åŒæ­¥æ¡†æ¶å›è°ƒ"]
    end
    
    subgraph "Runner å±‚"
        R["SkillRunner<br/>(çº¯ C#, æ¯è§’è‰²ä¸€ä¸ª)"]
    end
    
    subgraph "Process å±‚"
        PF["ProcessFactory<br/>(åå°„æ³¨å†Œ + å¯¹è±¡æ± )"]
        IP["IProcess â†’ ProcessBase&lt;TClip&gt;"]
    end
    
    subgraph "ç¼–è¾‘å™¨ç®¡ç†å™¨"
        EAM["EditorAudioManager"]
        EVM["EditorVFXManager"]
    end
    
    subgraph "æ•°æ®å±‚ (å·²æœ‰)"
        ST["SkillTimeline â†’ Group â†’ Track â†’ Clip"]
    end
    
    MONO & ED & FS -->|"Tick(dt)"| R
    R <-->|"Create/Return"| PF --> IP
    IP -->|"è¯»å–"| ST
    IP -->|"è°ƒç”¨"| EAM & EVM
```

---

## 2. æ ¸å¿ƒè®¾è®¡å†³ç­–æ±‡æ€»

| å†³ç­– | æ–¹æ¡ˆ | åŸåˆ™ |
|------|------|------|
| æ¸…ç†èŒè´£ | ä¸‰å±‚ï¼šOnExit(å®ä¾‹) / OnDisable(è¿›ç¨‹) / RegisterCleanup(ç³»ç»Ÿ) | SRP, ä¿¡æ¯ä¸“å®¶ |
| æ—¶é—´é©±åŠ¨ | Tick(dt) ç”±è°ƒç”¨æ–¹å†³å®šï¼ˆæ—  ITimeProviderï¼‰ | DIP |
| ç¼–è¾‘å™¨/è¿è¡Œæ—¶å¤šæ€ | ç‹¬ç«‹å­ç±» + [ProcessBinding] å·¥å‚ | OCP, LSP |
| Process å†…å­˜ | ProcessFactory å†…éƒ¨æ± åŒ– + Reset() | â€” |
| ç”Ÿå‘½å‘¨æœŸ | äº”é˜¶æ®µï¼šEnable/Enter/Update/Exit/Disable | ISP |
| äº‹ä»¶æ¨¡å‹ | Runner äº‹ä»¶è®¢é˜…é“¾ï¼ŒInterrupt æ—¶ ClearEvents | OCP |

---

## 3. æ¨¡å—è¯¦ç»†è®¾è®¡

### 3.1 IProcess + ProcessBase

```csharp
public interface IProcess
{
    void Initialize(ClipBase clipData, ProcessContext context);
    void Reset();       // å¯¹è±¡æ± å¤ç”¨å‰è°ƒç”¨
    void OnEnable();
    void OnEnter();
    void OnUpdate(float currentTime, float deltaTime);
    void OnExit();
    void OnDisable();
}

public abstract class ProcessBase<TClip> : IProcess where TClip : ClipBase
{
    protected TClip clip;
    protected ProcessContext context;
    
    public void Initialize(ClipBase clipData, ProcessContext context)
    {
        this.clip = (TClip)clipData;
        this.context = context;
    }
    
    public virtual void Reset() { clip = default; context = null; }
    public virtual void OnEnable() { }
    public virtual void OnEnter() { }
    public abstract void OnUpdate(float currentTime, float deltaTime);
    public virtual void OnExit() { }
    public virtual void OnDisable() { }
}
```

---

### 3.2 ProcessContext

```csharp
public class ProcessContext
{
    public GameObject Owner { get; }
    public Transform OwnerTransform { get; }
    public PlayMode PlayMode { get; }
    public object UserData { get; set; }
    
    // ç»„ä»¶ç¼“å­˜
    private Dictionary<Type, Component> componentCache = new Dictionary<Type, Component>();
    public T GetComponent<T>() where T : Component { /* æƒ°æ€§æŸ¥æ‰¾+ç¼“å­˜ */ }
    
    // ç³»ç»Ÿçº§æ¸…ç†æ³¨å†Œï¼ˆåŒ key å»é‡ï¼‰
    private Dictionary<string, Action> cleanupActions = new Dictionary<string, Action>();
    public void RegisterCleanup(string key, Action cleanup) => cleanupActions[key] = cleanup;
    internal void ExecuteCleanups()
    {
        foreach (var a in cleanupActions.Values) a.Invoke();
        cleanupActions.Clear();
    }
}

public enum PlayMode { EditorPreview, Runtime }
```

---

### 3.3 ProcessFactoryï¼ˆåå°„æ³¨å†Œ + å¯¹è±¡æ± ï¼‰

```csharp
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class ProcessBindingAttribute : Attribute
{
    public Type ClipType { get; }
    public PlayMode Mode { get; }
    public ProcessBindingAttribute(Type clipType, PlayMode mode) { ... }
}

public static class ProcessFactory
{
    private static Dictionary<(Type, PlayMode), Type> registry;
    private static Dictionary<Type, Queue<IProcess>> pools = new();
    
    static ProcessFactory()
    {
        registry = new Dictionary<(Type, PlayMode), Type>();
        foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
            foreach (var type in asm.GetTypes())
                foreach (var attr in type.GetCustomAttributes<ProcessBindingAttribute>())
                    registry[(attr.ClipType, attr.Mode)] = type;
    }
    
    public static IProcess Create(ClipBase clip, PlayMode mode)
    {
        if (!registry.TryGetValue((clip.GetType(), mode), out var pType)) return null;
        if (pools.TryGetValue(pType, out var pool) && pool.Count > 0)
        {
            var reused = pool.Dequeue();
            reused.Reset();
            return reused;
        }
        return (IProcess)Activator.CreateInstance(pType);
    }
    
    public static void Return(IProcess process)
    {
        if (process == null) return;
        var t = process.GetType();
        if (!pools.ContainsKey(t)) pools[t] = new Queue<IProcess>();
        pools[t].Enqueue(process);
    }
    
    public static void ClearPools() => pools.Clear();
}
```

---

### 3.4 SkillRunner

#### çŠ¶æ€æœº

```mermaid
stateDiagram-v2
    [*] --> Idle
    Idle --> Playing : Play()
    Playing --> Paused : Pause()
    Paused --> Playing : Resume()
    Playing --> Idle : Stop() / è‡ªç„¶ç»“æŸ
    Playing --> Playing : Play(new) è‡ªåŠ¨æ‰“æ–­
    Paused --> Idle : Stop()
```

#### äº‹ä»¶

```csharp
public event Action OnStart;
public event Action OnEnd;          // è‡ªç„¶ç»“æŸæˆ– Stop
public event Action OnInterrupt;    // è¢«æ–°æŠ€èƒ½æ‰“æ–­
public event Action OnPause;
public event Action OnResume;
public event Action OnLoopComplete; // å¾ªç¯ä¸€è½®
public event Action<float> OnTick;  // æ¯å¸§ (currentTime)
```

#### æ ¸å¿ƒæ–¹æ³•

```csharp
public class SkillRunner
{
    public enum State { Idle, Playing, Paused }
    
    public State CurrentState { get; private set; } = State.Idle;
    public float CurrentTime { get; private set; }
    public SkillTimeline Timeline { get; private set; }
    
    private PlayMode playMode;
    private ProcessContext context;
    private List<ProcessInstance> processes = new List<ProcessInstance>();
    
    private struct ProcessInstance
    {
        public IProcess process;
        public ClipBase clip;
        public bool isActive;
    }
    
    public SkillRunner(PlayMode mode) { playMode = mode; }
    
    // â”€â”€â”€ æ’­æ”¾æ§åˆ¶ â”€â”€â”€
    
    public void Play(SkillTimeline timeline, ProcessContext context) { /* ... */ }
    public void Pause()  { /* Playingâ†’Paused */ }
    public void Resume() { /* Pausedâ†’Playing */ }
    public void Stop()   { /* FullCleanup â†’ OnEnd â†’ ClearEvents */ }
    public void Seek(float targetTime) { /* è·³è½¬ï¼šExit è„±ç¦»åŒºé—´ã€Enter è¿›å…¥åŒºé—´ */ }
    
    // â”€â”€â”€ æ¯å¸§é©±åŠ¨ â”€â”€â”€
    
    public void Tick(float deltaTime)
    {
        if (CurrentState != State.Playing) return;
        CurrentTime += deltaTime * (Timeline?.playbackSpeed ?? 1f);
        
        // åŒºé—´æ‰«æï¼ˆEnter/Update/Exitï¼‰
        for (int i = 0; i < processes.Count; i++) { /* ... */ }
        
        OnTick?.Invoke(CurrentTime);
        
        if (CurrentTime >= Timeline.duration)
        {
            if (Timeline.isLoop)
                { ResetActiveProcesses(); CurrentTime = 0f; OnLoopComplete?.Invoke(); }
            else
                { FullCleanup(); CurrentState = State.Idle; OnEnd?.Invoke(); ClearEvents(); }
        }
    }
    
    // â”€â”€â”€ æ¸…ç†ï¼ˆä¸‰å±‚ + æ± å½’è¿˜ï¼‰â”€â”€â”€
    
    private void FullCleanup()
    {
        foreach (var inst in processes)
            if (inst.isActive) inst.process.OnExit();        // çº§åˆ«1: å®ä¾‹
        foreach (var inst in processes)
            inst.process.OnDisable();                         // çº§åˆ«2: è¿›ç¨‹
        foreach (var inst in processes)
            ProcessFactory.Return(inst.process);              // å½’è¿˜æ± 
        processes.Clear();
        context?.ExecuteCleanups();                            // çº§åˆ«3: ç³»ç»Ÿ
    }
}
```

---

### 3.5 SkillLifecycleManager

```csharp
public class SkillLifecycleManager : MonoBehaviour
{
    public static SkillLifecycleManager Instance { get; private set; }
    private List<SkillRunner> activeRunners = new List<SkillRunner>();
    
    private void Awake() { /* å•ä¾‹, DontDestroyOnLoad */ }
    private void Update()
    {
        float dt = Time.deltaTime;
        for (int i = activeRunners.Count - 1; i >= 0; i--)
            activeRunners[i].Tick(dt);
    }
    public void Register(SkillRunner runner) => activeRunners.Add(runner);
    public void Unregister(SkillRunner runner) => activeRunners.Remove(runner);
}
```

---

### 3.6 EditorVFXManager

```csharp
/// <summary>
/// ç¼–è¾‘å™¨é¢„è§ˆ VFX ç®¡ç†å™¨ï¼šå®ä¾‹æ±  + ParticleSystem é‡‡æ ·
/// </summary>
public class EditorVFXManager
{
    private static EditorVFXManager instance;
    public static EditorVFXManager Instance => instance ??= new EditorVFXManager();
    
    private GameObject vfxRoot;
    // æŒ‰é¢„åˆ¶ä½“ InstanceID åˆ†æ± 
    private Dictionary<int, Queue<GameObject>> pools = new();
    // æ´»è·ƒå®ä¾‹ â†’ é¢„åˆ¶ä½“ IDï¼ˆå½’è¿˜æ—¶å®šä½æ± ï¼‰
    private Dictionary<GameObject, int> activeInstances = new();
    
    /// ä»æ± å–æˆ–æ–°å»º VFX å®ä¾‹
    public GameObject Spawn(GameObject prefab, Vector3 position, Quaternion rotation)
    {
        EnsureRoot();
        int prefabId = prefab.GetInstanceID();
        GameObject inst;
        
        if (pools.TryGetValue(prefabId, out var pool) && pool.Count > 0)
        {
            inst = pool.Dequeue();
            inst.transform.SetPositionAndRotation(position, rotation);
            inst.SetActive(true);
        }
        else
        {
            inst = Object.Instantiate(prefab, position, rotation, vfxRoot.transform);
            inst.hideFlags = HideFlags.HideAndDontSave;
        }
        activeInstances[inst] = prefabId;
        RestartParticles(inst);
        return inst;
    }
    
    /// ParticleSystem é‡‡æ ·åˆ°æŒ‡å®šæ—¶é—´ï¼ˆSeek æ—¶ä½¿ç”¨ï¼‰
    public void Sample(GameObject instance, float time)
    {
        if (instance == null) return;
        foreach (var ps in instance.GetComponentsInChildren<ParticleSystem>())
        {
            ps.Stop(true, ParticleSystemStopBehavior.StopEmittingAndClear);
            ps.Simulate(time, true, true, false);
        }
    }
    
    /// å›æ”¶å®ä¾‹åˆ°æ± 
    public void Return(GameObject instance)
    {
        if (instance == null || !activeInstances.TryGetValue(instance, out int prefabId)) return;
        StopParticles(instance);
        instance.SetActive(false);
        activeInstances.Remove(instance);
        if (!pools.ContainsKey(prefabId)) pools[prefabId] = new Queue<GameObject>();
        pools[prefabId].Enqueue(instance);
    }
    
    public void ReturnAll() { foreach (var inst in new List<GameObject>(activeInstances.Keys)) Return(inst); }
    public void Dispose() { if (vfxRoot) Object.DestroyImmediate(vfxRoot); pools.Clear(); activeInstances.Clear(); instance = null; }
    
    private void EnsureRoot() { if (!vfxRoot) { vfxRoot = new GameObject("[EditorVFXPreview]"); vfxRoot.hideFlags = HideFlags.HideAndDontSave; } }
    private void RestartParticles(GameObject inst) { foreach (var ps in inst.GetComponentsInChildren<ParticleSystem>()) { ps.Clear(true); ps.Play(true); } }
    private void StopParticles(GameObject inst) { foreach (var ps in inst.GetComponentsInChildren<ParticleSystem>()) ps.Stop(true, ParticleSystemStopBehavior.StopEmittingAndClear); }
}
```

---

### 3.7 EditorAudioManager

```csharp
public class EditorAudioManager
{
    private static EditorAudioManager instance;
    public static EditorAudioManager Instance => instance ??= new EditorAudioManager();
    
    private GameObject audioRoot;
    private Queue<AudioSource> pool = new();
    private List<AudioSource> active = new();
    
    public AudioSource Get() { /* ä»æ± å–æˆ–æ–°å»º AudioSource */ }
    public void Return(AudioSource src) { /* åœæ­¢ â†’ å½’æ±  */ }
    public void Dispose() { /* DestroyImmediate root */ }
}
```

---

## 4. ç¼–è¾‘å™¨é¢„è§ˆé›†æˆ

### 4.1 TimeStepMode é©±åŠ¨

ç¼–è¾‘å™¨é¢„è§ˆçš„ deltaTime æ ¹æ® `SkillEditorState.timeStepMode` å†³å®šï¼š

| TimeStepMode | deltaTime | è¯´æ˜ |
|-------------|-----------|------|
| `Variable` | `EditorApplication.timeSinceStartup` å·®å€¼ï¼ˆå®æ—¶ï¼‰ | ä¸åšå¸§çº¦æŸ |
| `Fixed` | `1f / state.frameRate`ï¼ˆå›ºå®šæ­¥é•¿ï¼Œå¦‚ 1/30ï¼‰ | æ¨¡æ‹Ÿå¸§åŒæ­¥ |

### 4.2 SkillEditorWindow.Preview.cs

```csharp
public partial class SkillEditorWindow
{
    private SkillRunner previewRunner;
    private double lastPreviewTime;
    
    private void InitPreview()
    {
        previewRunner = new SkillRunner(PlayMode.EditorPreview);
    }
    
    public void StartPreview()
    {
        if (state.currentTimeline == null || state.previewTarget == null) return;
        var ctx = new ProcessContext(state.previewTarget, PlayMode.EditorPreview);
        lastPreviewTime = EditorApplication.timeSinceStartup;
        previewRunner.Play(state.currentTimeline, ctx);
    }
    
    public void StopPreview() => previewRunner?.Stop();
    
    /// <summary>
    /// EditorApplication.update å›è°ƒä¸­è°ƒç”¨
    /// </summary>
    private void OnPreviewUpdate()
    {
        if (previewRunner?.CurrentState != SkillRunner.State.Playing) return;
        
        float dt;
        if (state.timeStepMode == TimeStepMode.Fixed)
        {
            // Fixed æ¨¡å¼ï¼šå›ºå®šæ­¥é•¿ï¼Œæ¨¡æ‹Ÿå¸§åŒæ­¥
            dt = 1f / state.frameRate;
        }
        else
        {
            // Variable æ¨¡å¼ï¼šå®æ—¶ delta
            double now = EditorApplication.timeSinceStartup;
            dt = Mathf.Min((float)(now - lastPreviewTime), 0.1f);
            lastPreviewTime = now;
        }
        
        previewRunner.Tick(dt);
        // åŒæ­¥æ—¶é—´æŒ‡é’ˆåˆ° stateï¼ˆä¾› UI æ˜¾ç¤ºï¼‰
        state.timeIndicator = previewRunner.CurrentTime;
        Repaint();
    }
}
```

### 4.3 é¢„è§ˆè§’è‰²é€‰æ‹©å™¨

`SkillEditorState` æ–°å¢å­—æ®µï¼š

```csharp
// SkillEditorState ä¸­
public GameObject previewTarget;  // é¢„è§ˆè§’è‰²
```

`ToolbarView` ä¸­æ¢å¤é€‰æ‹©å™¨ UIï¼š

```csharp
// ToolbarView ä¸­
state.previewTarget = (GameObject)EditorGUILayout.ObjectField(
    Lan.PreviewTarget, state.previewTarget, typeof(GameObject), true);

if (state.previewTarget == null)
{
    if (GUILayout.Button(Lan.CreateDefaultCharacter))
    {
        var prefab = AssetDatabase.LoadAssetAtPath<GameObject>(
            "Assets/SkillEditor/Editor/Resources/DefaultPreviewCharacter.prefab");
        if (prefab != null)
            state.previewTarget = Object.Instantiate(prefab);
    }
}
```

---

## 5. è¿è¡Œæ—¶ä½¿ç”¨ç¤ºä¾‹

```csharp
// éå¸§åŒæ­¥
public class CharacterSkillController : MonoBehaviour
{
    private SkillRunner runner;
    private ProcessContext context;
    
    private void Start()
    {
        runner = new SkillRunner(PlayMode.Runtime);
        context = new ProcessContext(gameObject, PlayMode.Runtime);
        SkillLifecycleManager.Instance.Register(runner);
    }
    
    public void CastSkill(SkillTimeline skill)
    {
        runner.OnEnd += () => animComponent.PlayIdle();
        runner.OnInterrupt += () => animComponent.PlayIdle();
        runner.Play(skill, context);
    }
}

// å¸§åŒæ­¥
public class FrameSyncSkillController
{
    private SkillRunner runner;
    public void OnLogicFrame(float fixedDelta) => runner.Tick(fixedDelta);
}
```

---

## 6. ç›®å½•ç»“æ„

```
Assets/SkillEditor/
â”œâ”€â”€ Runtime/Playback/
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”œâ”€â”€ IProcess.cs
â”‚   â”‚   â”œâ”€â”€ ProcessBase.cs
â”‚   â”‚   â”œâ”€â”€ ProcessContext.cs
â”‚   â”‚   â”œâ”€â”€ ProcessBindingAttribute.cs
â”‚   â”‚   â”œâ”€â”€ ProcessFactory.cs
â”‚   â”‚   â””â”€â”€ SkillRunner.cs
â”‚   â”œâ”€â”€ Lifecycle/
â”‚   â”‚   â””â”€â”€ SkillLifecycleManager.cs
â”‚   â””â”€â”€ Processes/
â”‚       â””â”€â”€ Runtime[Type]Process.cs Ã— 6
â”œâ”€â”€ Editor/
â”‚   â”œâ”€â”€ Resources/
â”‚   â”‚   â””â”€â”€ DefaultPreviewCharacter.prefab
â”‚   â””â”€â”€ Playback/
â”‚       â”œâ”€â”€ Editor[Type]Process.cs Ã— 3+
â”‚       â”œâ”€â”€ EditorAudioManager.cs
â”‚       â”œâ”€â”€ EditorVFXManager.cs
â”‚       â””â”€â”€ SkillEditorWindow.Preview.cs
```

---

## 7. éœ€æ±‚å¯¹ç…§

| # | éœ€æ±‚ | æ–¹æ¡ˆ |
|---|------|------|
| 1 | Mono å•ä¾‹ | SkillLifecycleManager |
| 2 | Process äº”é˜¶æ®µ | IProcess + ProcessBase + Reset |
| 3 | è·¨è½¨é“å¹¶è¡Œ | æ‰å¹³åˆ—è¡¨ + åŒºé—´æ‰«æ |
| 4 | å¤šæ’­æ”¾æ¨¡å¼ | Tick(dt)ï¼Œç¼–è¾‘å™¨æŒ‰ TimeStepMode é©±åŠ¨ |
| 5 | å¤šæ€å®ç° | ç‹¬ç«‹å­ç±» + å·¥å‚ |
| 6 | ä¾èµ–æ³¨å…¥ | ProcessContext |
| 7 | å¯æ‰©å±•å·¥å‚ | [ProcessBinding] + åå°„ |
| 8 | Runner é Mono | çº¯ C# |
| 9 | å¤š Runner å¹¶è¡Œ | ç®¡ç†å™¨åˆ—è¡¨ |
| 10 | å±‚é—´éš”ç¦» | ç›®å½• + partial |
| ğŸ†• | ä¸‰å±‚æ¸…ç† | OnExit / OnDisable / RegisterCleanup |
| ğŸ†• | Process å¯¹è±¡æ±  | ProcessFactory å†…éƒ¨æ‰˜ç®¡ |
| ğŸ†• | EditorVFXManager | å®ä¾‹æ±  + Simulate é‡‡æ · |
| ğŸ†• | EditorAudioManager | AudioSource æ±  |
| ğŸ†• | è§’è‰²é€‰æ‹©å™¨ | ToolbarView + previewTarget |
| ğŸ†• | TimeStepMode | Variable(å®æ—¶) / Fixed(1/fps) |
| ğŸ†• | æ’­æ”¾æ§åˆ¶ | çŠ¶æ€æœº + Pause/Resume/Interrupt |
| ğŸ†• | äº‹ä»¶è®¢é˜… | OnEnd/OnInterrupt/OnLoopComplete... |
| ğŸ†• | Seek | ç›´æ¥è·³è½¬ + Exit/Enter |

---

## 8. å®æ–½é¡ºåº

| é˜¶æ®µ | äº§å‡º |
|------|------|
| **Phase 1** | `IProcess`, `ProcessBase`, `ProcessContext`, `ProcessBindingAttribute`, `ProcessFactory` |
| **Phase 2** | `SkillRunner` |
| **Phase 3** | `EditorAudioManager`, `EditorVFXManager` |
| **Phase 4** | EditorProcess éª¨æ¶ + `SkillEditorWindow.Preview.cs` + è§’è‰²é€‰æ‹©å™¨ |
| **Phase 5** | RuntimeProcess éª¨æ¶ + `SkillLifecycleManager` |
