# 采样频率导致的过渡差异（部分原因）

> 之前想了那么就为什么过渡时动作会异常，没想到居然是片段长度与过渡blendin的问题。因为2个动画都是挥剑后还有一个后摇恢复到持剑待机的动作，当我把它们的片段长度匹配到animationclip的长度时，再去融合，虽然在编辑器预览时没什么异常，但是一到运行时就能看出动作异常。目前解决办法就是把重叠部分及第一个片段的blendout第二个片段的blendin调大一点，那么运行时就会很正常。那么之前为什么没有发现呢，归根到底是预览播放和运行时播放还是存在差异，比如当前运行时比较合适clip2的blendin是2.3，而预览时则是1.4，虽然感觉数值也都有点太大了，但也能看出二者的差异。

- 编辑器预览播放和运行时播放的采样频率不同，预览时权重的更新频率与技能逻辑的更新频率同步，动画采样每个逻辑帧执行一次，是离散的，而运行时权重的更新频率则是单独同步于MonoUpdate，动画采样由AnimationClipPlayable自动进行，是连续的。显然前者动画采样频率低，而逻辑帧率通常也会比MonoUpdate帧率低，导致了前者会渲染更少的帧。
- 即：预览模式因为帧率或采样机制的不同，**跳过了那个出错的瞬间**，而运行时（通常帧率更高且连续）则忠实地渲染了那个糟糕的混合帧。
- **现象**：假设在混合权重的 0.48~0.52 区间内（即两个动作冲突最剧烈的时刻），角色的姿势会发生扭曲。
- **结果**：运行时这一帧被渲染出来，您看到了“抽搐”。而预览模式恰好从 0.46 跳到了 0.54，直接**跳过了这一帧糟糕的姿势**，看起来就无比顺滑。

# 精度丢失导致的误差累积（根本原因）

Debug信息

```c#
Clip1 [OnEnter] Play at time: 0.02，  
Clip2 [OnEnter] Play at time: 2.265074
```

理论数据f

```c#
Clip1 [OnEnter] Play at time: 0 ->  测试技能的Clip1的startTime为 0
Clip2 [OnEnter] Play at time: 2.265074 ->  测试技能的Clip2的startTime为 1.7f
```

- 当**SkillRunner**认为到了 1.7s 并触发 Clip2 时，Unity 的动画系统已经播放了 2.24s。
- Clip1 的长度只有 3.16s。在 2.24s 时触发 Clip2，只剩下 0.92s 的时间。
- 但是配置的过渡时间是 1.46s。**剩余时间不足以完成过渡！**
- 这导致 Clip1 会播放完并进入 Hold/Loop 状态，而 Clip2 还在淡入，从而产生“异常动作”。

### 问题根源：

- **原来的驱动Runner的外部顶层计时器逻辑错误**

### 错误写法

```c#
//原本的逻辑
timer += Time.deltaTime;
if (timer >= 0.0333f) 
{
    timer = 0f; // <--- 致命错误：直接归零丢弃了余数！
    runner.Tick(0.0333f);
}
```

**Frame 1**: 

```c#
timer = 0.04s (满足 >= 0.0333)。
->timer归零
->Runner前进0.0333s
->丢失时间：0.04s-0.0333s=0.0067s
```

**Frame 2**: 

```c#
timer = 0.04s (满足 >= 0.0333)。
->timer归零
->Runner前进0.0333s
->再次丢失：0.04s-0.0333s=0.0067s
```

### 正确的写法 (Accumulator Pattern)

如果想模拟稳定的 30 FPS 更新（常用于帧同步），必须保留余数：

```c#
//正确的逻辑
timer += Time.deltaTime;
float step = 1f / 30f;

// 使用 while 处理单帧时间过长的情况（追帧）
while (timer >= step)
{
    timer -= step; // <--- 关键：减去步长，保留余数 (0.04 - 0.0333 = 0.0067)
    runner.Tick(step);
}
// 剩余的 0.0067 会累加到下一帧，绝不丢失
```

