# 玩家输入与战斗控制体系：进阶架构设计 (Input Config & Hybrid Control)

在阶段一、二的纯“方向盘打火跑跑停停”基础上，我们迎来商业化 MMO/ACT 的核心难题：
**如何处理允许玩家自定改键的“普攻、跳跃、冲刺及四个技能插槽”？如果它们全部堆进 FSM，状态流转该如何解脱？**

## User Review Required

> [!IMPORTANT]
> 这是针对您“跳跃下落、配置按键、多个动作技能”需求，客观分析后拿出的**进阶混合架构案**。
> 本案对纯 FSM 的死胡同做出了驳斥，并引出业界最佳实践（Locomotion 分层 + 技能插槽打断机制）。
> 请您评估本方案，这决定了接下来我们扩展输入模块和重构 `PlayerEntity` 的走向。

## 架构对比与客观分析 (为什么还要其他方案？)

如果采用**纯有限状态机 (Pure FSM)**，面对您的需求，我们需要写：`IdleState`, `MoveState`, `JumpState`, `FallState`, `AttackState`, `Skill1~4State`, `DashState`。
*   **致命缺陷：状态爆炸。** 当策划说“能在半空中放冲刺和 2 技能”时，您必须人工捏造 `AirDashState`, `AirSkill2State`，并且重新梳理全部拉线转换。
*   **结论**：用 FSM 去承载“战斗技能”，在一线大厂的重度动作项目中是被严厉禁止的做法。

### 🌟 行业最佳实践：混合分层架构 (Locomotion + Ability System)
这是类似 Unreal Engine GAS (Gameplay Ability System) 或部分次世代自研引擎采用的模型。我们将大脑劈开为两大半球（**注意：这里的“分层”主要指“逻辑控制权的分层”，不仅指骨骼动画的上下半身分离**）：

1.  **底盘：物理与基础位移逻辑 (Locomotion FSM)**
    *   **负责**：永远只存在两个大状态。贴着地的（`GroundState`，内部根据速度播站立或跑） 和 没贴地的（`AirborneState`，内部播起跳、坠落、硬着陆）。
    *   **职责纯粹**：它根本不知道什么叫“火球术”和“三连砍”，只管按照牛顿定律在世界坐标中移动胶囊体。
2.  **上层：动作/技能指令路由 (Action/Ability Router)**
    *   **负责**：所有的平 A (左键)、技能 (Alpha1~4)、闪避 (Shift)。
    *   **截断与兼容机制 (全身动画完全适用)**：当玩家按下技能键时，指令台立即被激活，它朝 `Locomotion FSM` 发送一个 **Freeze/Override (挂起/覆盖)** 指令。
        *   **【硬接管（全身动作）】**：这是动作游戏最常见的模式（也是您的应用场景）。比如释放“旋风斩”是全身动画，此时 Ability 路由完全冻结底部的 FSM，剥夺玩家控制摇杆走动的权力。全身开始播放这一个动画 `AnimationClip`，且该动画自身的 RootMotion（或者 `SkillEditor` 里配的位移轨道）接管了真实的位移。播完后，解冻 FSM，重获走跑跳能力。
        *   **【软接管（半身分层）】**：未来如果您想实现“边跑边开枪”，Ability 路由则不冻结 FSM 移动，而是只要求底层动画系统（`MAnimSystem`）把攻击动画盖在脊椎以上的骨架上。
    *   **结论**：这种架构**极度通用且兼容**。它抽象了“放技能”这件事本身的霸体优先级，不论是全身动画（暂停 FSM）还是半身分离（不暂停 FSM），都能在一个体系内干净闭环，有效避免了将这些判断散漫地写进 FSM 跳转连线中。

---

## 具体模块落地拆解

### 1. 自定义热更新输入层 (Input System Rebinding)
Unity 的 `New Input System` 天然就是为了“运行时改键”设计的。
*   **Action Map 调整**：我们将在 UI 或配置表中，开放 `PlayerInputActions.inputactions` 资产。
*   **IInputProvider 接口猛增**：
    除了之前给状态机看是否转摇杆的方法，新开一排基于委托的“插槽”：
    ```csharp
    // InputAction.CallbackContext 转化而来的纯粹 Action
    event Action OnBasicAttack;
    event Action OnSkill1;
    // ...
    event Action OnDash;
    event Action OnJump;
    ```
*   **配置存储**：调用 InputSystem 内置的 `SaveBindingOverridesAsJson()`，把用户的改键变成一段 String 扔进 Config 或本地存档。玩家下一次登录原样加载。

### 2. 重构大基础状态机 (Ground & Air)
合并之前拆得太碎的 `Idle` 和 `Move`，做一套真正处理落水管、起跳碰撞的 Locomotion：
*   **`PlayerGroundState`**：拿到 `Vector2`，如果在移动就掉点速度让 `IAnimController` 播跑，停下就播站。如果此时 `IInputProvider.OnJump` 响了，给个瞬间向上的 Y 轴冲量，立刻 `ChangeState<PlayerAirborneState>`。
*   **`PlayerAirborneState`**：在 Update 中每帧打一条脚底射线（或 `CharacterController.isGrounded`）。离地就用重力抛物线算下落，一旦碰地则切回 `GroundState`。

### 3. Ability 控制器 (打通你的 SkillEditor)
主角身上除了 FSM，再挂一个 `PlayerAbilityController`。
*   **它监听所有带杀气按键**：`OnBasicAttack`, `OnSkill1...4`
*   **执行拦截**：一旦触发，它向 `PlayerEntity` 申请“我想强占控制权”。如果成功，`Entity` 会执行 `StateMachine.Pause()`。
*   **派发技能**：它向您的系统派发指定 ID，等时间轴运行到尾巴时，发事件通知 `Entity`：我打完了，`StateMachine.Resume()` 吧。

---

## 数据流向与装配图解

```mermaid
graph TD
    A[New Input System<br>(提供 JSON 运行时改键)] -->|包装剥离| P[IInputProvider]

    P -- 1. 摇杆/空间键 --> L(基础物理 FSM: Locomotion)
    L -- 平凡步态: 贴地 / 空中抛物线 --> E[IAnimController]
    L -- 普通寻路推挤 --> M[IMovementController]

    P -- 2. 鼠标左/1-4键 --> S(动作技能总线: AbilityRouter)
    S -- "停下!我要放技能了" -->|挂起锁死| L
    S -- 唤醒您现有的时间轴 --> G[SkillEditor 核心层]
    G -- 根运动强制覆盖 --> E
    G -- 技能演毕 -->|解冻重启| L
```

## 实施流程 (Verification Plan)
待您确立此项融合分层架构后：
1. **重筑 Input 映射表**：使用 Unity New Input 建立包含平 A、4 个技能套件的资产，支持覆写接口。
2. **重构 Locomotion FSM**：删掉脆弱的 `PlayerIdleState`，变成只关注“脚丫子有没有贴着地”的强健 Locomotion（地/空双态）。
3. **加装截断阀门**：在 FSM 系统或 Entity 中添加拦截状态机运作的功能，预设出 Ability 接管的切口。
